///////////////////////////////////////////////////////////////////////////////
//
// Revolution external definition file for 'rnahello'
//
// Generated by External Creator V1.00
//
// Language: C++ (no exceptions, no rtti)
//

#include <cstdlib>
#include <cstdio>
#include <cstring>

#include <revolution/external.h>

///////////////////////////////////////////////////////////////////////////////
//
// BEGIN USER DEFINITIONS

// Function:
//   rnaHelloUser(pName)
// Parameters:
//  pName – string
// Result:
//   a string containing a friendly message
//
void rnaHelloUser(char *p_arguments[], int p_argument_count, char **r_result, Bool *r_pass, Bool *r_err)
{
	// First check we have been passed a single argument – if not it’s an error
	//
	if (p_argument_count != 1)
	{
		*r_result = strdup("wrong number of parameters");
		*r_err = True;
		*r_pass = False;
		return;
	}

	// Next compute the length of our required string
	//   = length of first argument (p_arguments[0]) + length of "Hello, !" + 1
	//
	unsigned int t_buffer_length;
	char *t_buffer;
	t_buffer_length = strlen(p_arguments[0]) + 8 + 1;
	t_buffer = (char *)malloc(t_buffer_length);
	if (t_buffer == NULL)
	{
		*r_result = strdup("out of memory");
		*r_err = True;
		*r_pass = False;
		return;
	}

	// We have allocated our buffer – so now construct our string
	//
	sprintf(t_buffer, "Hello, %s!", p_arguments[0]);

	// t_buffer now contains a pointer to the result so just return...
	//
	*r_result = t_buffer;
	*r_err = False;
	*r_pass = False;
}

// Command:
//   rnaHelloUserIndirect pUserVariableName, pOutputVariableName
// Parameters:
//  pUserVariableName – name of a variable in local context to get the name from
//  pOutputVariableName – name of a variable in local context to put the result into
//
void rnaHelloUserIndirect(char *p_arguments[], int p_argument_count, char **r_result, Bool *r_pass, Bool *r_err)
{
	// In this command we have to keep track of several (memory) resources. To help with this
	// we use a variable 't_error' that determines whether an error has occured. This is used
	// throughout the function to determine whether to continue processing, and at the end to
	// decide whether to return an error or not.
	//
	const char *t_error;
	t_error = NULL;

	// Check to see if we have been passed two parameters
	//
	if (t_error == NULL && p_argument_count != 2)
		t_error = "wrong number of parameters";

	// Fetch the value of the 'name' variable (argument 1)
	// Remember that the return value of 'GetVariable' becomes 'ours' so we have to
	// free it later if the call succeeds.
	//
	char *t_name;
	t_name = NULL;
	if (t_error == NULL)
	{
		int t_success;
		t_name = GetVariable(p_arguments[0], &t_success);
		if (t_success == EXTERNAL_FAILURE)
			t_error = "unable to get value of name variable";
	}

	// Allocate memory for the return message to be put into the output variable
	// (If this step succeeds, we need to free memory pointed to by t_message later)
	//
	char *t_message;
	t_message = NULL;
	if (t_error == NULL)
	{
		t_message = (char *)malloc(strlen(t_name) + 8 + 1);
		if (t_message == NULL)
			t_error = "out of memory";
	}

	// Format our message appropriately
	//
	if (t_error == NULL)
		sprintf(t_message, "Hello, %s!", t_name);

	// Set the value of the output variable
	//
	if (t_error == NULL)
	{
		int t_success;
		SetVariable(p_arguments[1], t_message, &t_success);
		if (t_success == EXTERNAL_FAILURE)
			t_error = "unable to set output variable";
	}

	// Free the message memory buffer if it was ever allocated
	//
	if (t_message != NULL)
		free(t_message);

	// Free the name memory buffer if it was ever allocated
	//
	if (t_name != NULL)
		free(t_name);

	// If we succeeded, return an empty result and no error, otherwise return a copy
	// of the error message and flag as an error.
	// (NB: We return a pointer to NULL here because pre-2.5 versions of Revolution would crash if you returned a NULL pointer in r_result)
	//
	if (t_error == NULL)
	{
		*r_result = strdup("");
		*r_pass = False;
		*r_err = False;
	}
	else
	{
		*r_result = strdup(t_error);
		*r_pass = False;
		*r_err = True;
	}
}

// END USER DEFINITIONS
//
///////////////////////////////////////////////////////////////////////////////


EXTERNAL_BEGIN_DECLARATIONS("rnahello")

// BEGIN USER DECLARATIONS

EXTERNAL_DECLARE_FUNCTION("rnahellouser", rnaHelloUser)

EXTERNAL_DECLARE_COMMAND("rnahellouserindirect", rnaHelloUserIndirect)

// END USER DECLARATIONS

EXTERNAL_END_DECLARATIONS
