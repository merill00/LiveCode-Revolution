///////////////////////////////////////////////////////////////////////////////
//
// Revolution external main entry point for 'rnaeffect'
//
// Generated by External Creator V1.00
//
// For language: C++
//

#include <string>
#include <memory>

#include <revolution/external.h>

#include "utility.h"
#include "variable.h"
#include "effect.h"

///////////////////////////////////////////////////////////////////////////////
//
// BEGIN USER DEFINITIONS
//

// 'rnaListEffects' returns a return-delimited list of all currently known
// effects.
//
void rnaListEffects(char *p_arguments[], int p_argument_count, char **r_result, Bool *r_pass, Bool *r_error)
{
	if (p_argument_count != 0)
		throw ErrorException("illegal number of parameters");

	*r_pass = False;
	*r_error = False;
	*r_result = strdup(Effect::Enumerate() . c_str());
}

// 'rnaApplyEffect' takes three parameters
//   <pEffectInfoVariableName>
//   <pInputImageVariableName>
//   <pOutputImageVariableName>
// It creates an effect based on the contents of the pEffectInfoVariableName
// variable, then applies it to the data supplied in the pInputImageVariableName
// variable, putting the output in the pOutputImageVariableName variable.
//
// pEffectInfoVariableName should be an array variable with at least one element
// with key 'name' containing the name of the effect to apply. Other elements
// are defined by the individual effects.
//
// pInputImageVariableName should be an array variable describing the input image
// data. It should have the following keys:
//   width - the width of the image in pixels
//   height - the height of the image in pixels
//   color - the color data of the image in 'imageData' format (optional)
//   alpha - the alpha data of the image in 'alphaData' format (optional)
//
// On return, pOutputImageVariableName will be set to an array variable with
// the same keys. (The presence of color or alpha elements will depend on the
// effect being applied).
//
// Note: If both color and alpha elements are empty or not-present in the input
// image variable, then no processing will be done except to compute the
// resultant size of the image after the effect has been applied.
//
void rnaApplyEffect(char *p_arguments[], int p_argument_count, char **r_result, Bool *r_pass, Bool *r_error)
{
	// Check to see if we have the right number of parameters.
	//
	if (p_argument_count != 3)
		throw ErrorException("illegal number of parameters");

	// Attempt to create the given effect. Here we wrap the pointer to the effect
	// object in a standard 'auto_ptr'. This ensures if an exception occurs
	// the effect object will get cleaned up automagically.
	//
	std::auto_ptr<Effect> t_effect;
	t_effect . reset(Effect::Create(p_arguments[0]));

	// Wrap the input image variable in our Variable abstraction.
	//
	Variable t_input_info(p_arguments[1]);

	// Extract all the relevant information from the input image array.
	//
	Image t_input;

	// First get the width and height. Remember that the Variable wrapper will
	// throw appropriate exceptions in the case where there is a data-type
	// mismatch, so error-handling is entirely implicit and we don't have to
	// worry about it.
	//
	t_input . width = t_input_info . GetUnsignedIntegerElement("width");
	t_input . height = t_input_info . GetUnsignedIntegerElement("height");

	// Now we get the color and alpha data pointers. Here we use the RawString
	// forms for efficiency. These data-types return direct pointers to the
	// internal strings used by the Revolution engine so we avoid any copy
	// overhead and don't have to worry about freeing the memory.
	//
	ExternalString t_color_data;
	t_color_data = t_input_info . GetRawStringElement("color");
	if (t_color_data . length == t_input . width * t_input . height * 4)
		t_input . color = (unsigned char *)t_color_data . buffer;
	else if (t_color_data . length == 0)
		t_input . color = NULL;
	else
		throw ErrorException("input color data is the wrong size");

	ExternalString t_alpha_data;
	t_alpha_data = t_input_info . GetRawStringElement("alpha");
	if (t_alpha_data . length == t_input . width * t_input . height)
		t_input . alpha = (unsigned char *)t_alpha_data . buffer;
	else if (t_alpha_data . length == 0)
		t_input . alpha = NULL;
	else
		throw ErrorException("input alpha data is the wrong size");

	// Now we have our input image data we calculate the resulting output image
	// size.
	//
	Image t_output;
	t_effect -> Calculate(t_input . width, t_input . height, t_output . width, t_output . height);

	// First allocate memory for the output color data. We use a variant of
	// 'auto_ptr' here that manages an array.
	//
	auto_array_ptr<unsigned char> t_output_color;
	if (t_input . color != NULL)
		t_output_color . reset(new unsigned char[t_output . width * t_output . height * 4]);
	t_output . color = t_output_color . get();

	// Now do the same for the output alpha data.
	//
	auto_array_ptr<unsigned char> t_output_alpha;
	if (t_input . alpha != NULL)
		t_output_alpha . reset(new unsigned char[t_output . width * t_output . height]);
	t_output . alpha = t_output_alpha . get();

	// Apply the effect if we have any data to process
	//
	if (t_output . color != NULL || t_output . alpha != NULL)
		t_effect -> Apply(t_input, t_output);
	
	// Now build up the output image array. This is the same format as the input
	// image array - width, height, color and alpha.
	//
	Variable t_output_info(p_arguments[2]);
	t_output_info . SetUnsignedIntegerElement("width", t_output . width);
	t_output_info . SetUnsignedIntegerElement("height", t_output . height);
	if (t_output . color != NULL)
		t_output_info . SetRawBufferElement("color", t_output . color, t_output . width * t_output . height * 4);
	if (t_output . alpha != NULL)
		t_output_info . SetRawBufferElement("alpha", t_output . alpha, t_output . width * t_output . height);

	// If we got to here it means there were no errors
	//
	*r_pass = False;
	*r_error = False;
	*r_result = strdup("");

	// Because we used auto_array_ptr and auto_ptr to manage our dynamic memory
	// allocations (i.e. the Effect object and output data buffers) they will
	// be automagically freed at this point so we don't have to worry about them.
}

//
// END USER DEFINITIONS
//
///////////////////////////////////////////////////////////////////////////////


EXTERNAL_BEGIN_DECLARATIONS("rnaeffect")

// BEGIN USER DECLARATIONS

EXTERNAL_DECLARE_FUNCTION("rnaListEffects", rnaListEffects)
EXTERNAL_DECLARE_COMMAND("rnaApplyEffect", rnaApplyEffect)

// END USER DECLARATIONS

EXTERNAL_END_DECLARATIONS